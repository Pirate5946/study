### 2.1 Java的 I/O类库的基本架构
Java的 I/O操作类 在 包 java.io下，有80个左右的类，大概可以分为4组

1、基于字节操作的 I/O接口	InputStream 和 OutputStream

2、基于字符操作的 I/O接口	Writer 和 Reader

3、基于磁盘操作的 I/O接口	File

4、基于网络操作的 I/O接口 	Socket

#### 数据传输 的 格式 和方式 
1、操作数据的方式是可以组合使用的，例如
 OutputStream out = new BufferedOutputStream( new ObjectOutputStream ( new FileOutputStream( "filename") ));
 
2、必须指定流最终写到什么地方，要么写到磁盘，要么写到网络中
#### 2.1.2	  基于字符的I/O操作接口
#### 2.1.3   字节与字符的转化接口
数据持久化和网络传输都是以字节进行的，从字符到字节需要转化
InputStreamReader 类是字节到字符的转化桥梁，从InputStream到Reader的过程需要指定编码字符集；

StreamDecoder完成字节到字符的解码的实现类

OutPutStreamWriter 类完成从字符到字节的编码，StreamEncoder完成字符到字节的解码

### 2.2	磁盘I/O工作机制		p30
#### 2.2.1    几种访问文件的方式
读取和写入文件 I/O 都是调用操作系统提供的接口，read（）,write()

系统调用可能会在内核空间地址和用户空间地址 进行切换；内核程序运行使用的内核空间地址和用户空间地址 会被操作系统隔离
磁盘I/O 数据从 磁盘----》内核空间----》用户空间

在内核空间使用缓存机制，同一段磁盘地址的空间数据，直接从内核空间缓存到用户程序，减少I/O的响应时间

1、标准访问文件的方式（通过读写缓存）
当应用程序调用read（）接口，操作系统先检查内核的高速缓存中有没有需要的数据 ，有就直接从 缓存中取；没有就从磁盘中读取，然后缓存在操作系统的缓存中
写入的方式是，用户的应用程序调用write（）接口，将数据从用户空间地址复制到内核空间地址的缓存中，这时对用户程序来说，写操作已经完成，由操作系统决定什么时候从内核的缓存中写入磁盘，除非用户显式地调用了sync同步命令

2、直接I/O的方式							p33
应用程序直接访问磁盘数据，不经过内核的高速缓存

3、同步 访问文件的方式
在数据安全性要求较高的环境中使用

4、异步访问文件的方式

5、内存映射的方式

#### 2.2.2	Java访问磁盘文件
如何将数据持久化到物理磁盘						p35

当传入一个文件路径时，将会根据路径创建一个File对象来表示这个文件，然后根据File对象创建真正读取这个文件的操作对象，这时将会真正创建一个关联真实磁盘文件的文件描述符 FileDescriptor，通过这个对象可以真正控制这个磁盘文件；

至于如何从磁盘驱动器上读取和写入数据由操作系统完成
需要完成字节到字符的编码和解码
#### 2.2.3	Java序列化技术
Java序列化就是将一个对象转换成一串二进制表示的字节数组，通过转移或保存这些字节数据来达到持久化的目的。

需要持久化，对象必须继承 java.io.Serializable 接口

反序列化则是将二进制的字节数组 构造成对象，必须有原始类作为模板

序列化的文件 二进制字节数据举例说明   				p36

虽然Java的序列化能够保证对象状态的持久保存，但是遇到一些对象结构复杂的情况还是比较难处理，以下是对复杂的对象情况的总结

1、当父类 继承 Serializable接口时，所有子类都可以被序列化

2、子类实现了Serializable接口，父类没有，父类中的属性不能被序列化（不报错，数据会丢失），子类中属性可以正确序列化

3、如果序列化的属性是对象，则这个对象必须实现Serializable接口，否则会报错

4、在反序列化时，如果对象的属性有删除或修改，则修改部分的属性会丢失，但不会报错

5、在反序列化时，如果serialVersionUID被修改，则反序列化时会失败
在纯Java环境下，Java序列化能够很好的工作，但是在多语言环境下，用Java序列化存储后，很难用其他语言还原出结果，在这种情况下，还是要尽量存储通用的数据结构，如JSON或者XML结构数据

### 2.3	网络I/O工作机制
通信协议和网络数据传输
#### 2.3.1	TCP状态转换							p39
在讨论如何进行Socket通信之前，先看看如何建立和关闭一个TCP连接

#### 2.3.2	影响网络传输的因素
将一份数据从一个地方正确地传输到另一个地方所需要的时间称为响应时间，影响响应时间的因素有很多

1、网络带宽，

2、传输距离

3、TCP拥塞控制


#### 2.3.3	Java  Socket的工作机制
Socket这个概念没有对应到一个具体的实体，它描述计算机之间完成相互通信的一种抽象功能。大部分情况下我们使用基于TCP/IP的流套接字，它是一种稳定的通信协议

主机A的应用程序要和主机B的应用程序通信，必须通过Socket建立连接，而建立Socket必须通过底层TCP/IP建立TCP连接，建立TCP连接需要底层IP寻址网络中的主机， 然后通过TCP或UDP的地址（也就是端口号）与指定的应用程序通信，通过一个Socket实例唯一表示一个主机上的应用程序的通信链路。	

#### 2.3.4 	建立通信链路

#### 2.3.5	数据传输						p42
通过Socket传输数据，当连接已经成功建立，服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和OutputStream对象，并通过这两个对象来交换数据

网络I/O都是通过字节流传输的，当创建Socket对象时，操作系统会为InputStream和OutputStream分配一定大小的缓存区，数据的写入和读取通过缓存区完成，

写入端将数据写到OutputStream对应的SendQ队列中，当队列填满时，数据将被转移到另一端InputStream的RecvQ队列中，如果RecvQ已经满了，那么OutputStream的write方法将会发生阻塞

缓存区的大小和写入端的速度以及读取端的速度非常影响这个连接的数据传输效率，两边同时传送数据可能会产生死锁

### 2.4	NIO的工作方式
#### 2.4.1	BIO带来的挑战
BIO即阻塞I/O，不管是磁盘I/O还是网络I/O，数据在写入OutputStream或者从InputStream读取时都有可能会阻塞，一旦阻塞，线程将会失去CPU的使用权，
#### 2.4.2	NIO的工作机制						p44

#### 2.4.3	Buffer的工作方式					p46

#### 2.4.4	NIO的数据访问方式					p48

### 2.5	I/O调优	
#### 2.5.1	磁盘I/O优化					p50
1、性能检测
在linux下 用iostat命令查看I/O性能，为了提升磁盘I/O性能，可以采用RAID（将不同的磁盘的组合起来形成磁盘阵列）
2、提升I/O性能的方法
- 增加缓存
- 优化磁盘的管理系统
- 设计合理的磁盘存储数据块
- 应用合理的RAID策略
#### 2.5.2	TCP网络参数调优				p51

####2.5.3	网络I/O优化					p53
- 减少网络交互的次数
- 减少网络传输数据量的大小
- 尽量减少编码
- 根据应用场景设计合适的交互方式，所谓的交互方式主要包括同步和异步，阻塞和非阻塞方式					p55

### 2.6	设计模式解析 --- 适配器模式
把一个类的接口变换成客户端能够接受的另一种接口，从而使两个接口不匹配，无法在一起工作的类，变得能够在一起工作
通常被用在一个项目需要应用一些开源框架一起工作的情况下
#### 2.6.1	适配器模式的结构					p58
1、target 目标接口

2、adaptee（源接口） 需要适配的接口

3、adapter 将源接口适配成目标接口，继承源接口，实现目标接口

#### 2.6.2	Java I/O中的适配器模式
InputStreamReader类的作用就是将InputStream适配到Reader

StringReader	将一个String类适配到Reader接口

### 2.7	设计模式解析 --- 装饰器模式			p59
使被装饰的类增强功能或提升性能
#### 2.7.1	装饰器模式的结构
1、Component：抽象组件，定义一组抽象的接口，规定被装饰组件的功能

2、ConcreteComponent：实现这个抽象组件的所有功能

3、Decorator：装饰器角色，持有一个Component对象实例的引用，定义一个与抽象组件一致的接口

4、ConcreteDecorator：具体的装饰器实现者，负责实现装饰器角色定义的功能

#### 2.7.2	Java I/O 中的装饰器模式
FilterInputStream：实现了InputStream并且持有了InputStream对象实例的引用，BufferedInputStream是具体的装饰器实现者，它给InputStream附加了功能，使InputStream读取的数据保存在内存中，提高读取性能



