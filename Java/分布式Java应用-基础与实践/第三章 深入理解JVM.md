## 3.1 Java代码的执行机制
Java文件编译成class文件，通过类加载机制加载进内存，最后通过cpu执行
### 3.1.1 Java源码编译机制
1. 分析和输入到符号表   
词法分析（com.sun.tool.javac.parser.Scanner）将代码字符转变为 token 序列;  
语法分析（com.sun.tools.javac.parser.Parser） 根据语法由token序列生成抽象语法树

Enter(com.sun.tools.javac.comp.Enter) 过程为将符号输入到符号表
2. 注解处理 
处理用户自定义的 annotation ，
3. 语义分析和生成 class 文件

在完成分析后，开始生成class文件（com.sun.tools.javac.jvm.Gen），

---
class 文件中不仅存放了字节码，还存放了很多辅助JVM来执行class的附加信息，一个class文件包括
- 结构信息

- 元数据
- 方法信息

class文件是个完整的自描述文件，字节码在其中只占了很小的部分，源码编译为class文件后，即可放入jvm执行。    
执行时JVM首先要做的是装载class文件，这个机制称为类加载机制  
### 3.1.2 类加载机制    
类加载机制是指 class文件加载到 JVM，并形成 Class对象的机制。   
应用之后可以对 Class对象进行实例化并调用，类加载机制可以在运行时动态加载外部的类，还可以达到类隔离的效果    

1. 装载         

2. 链接

3. 初始化   
执行类中的静态初始化代码，构造器代码以及静态属性的初始化，在一下四种情况下 初始化过程会被触发执行： 
- 调用了new
- 反射调用了类中的方法
- 子类调用了初始化
- JVM启动过程中指定的初始化类


> 类加载器的继承关系

1. Bootstrap ClassLoader
2. Extension ClassLoader
3. System ClassLoader

4. User-Defined ClassLoader

### 3.1.3 类执行机制
在完成将class文件加载到JVM并产生Class对象后，就可执行Class对象的静态方法或实例化对象进行调用了   

在源码编译阶段，源码被编译成JVM字节码，JVM字节码是一种中间代码的方式，要由JVM在运行期对其进行解释并执行

### 字节码解释执行
JVM有一套自己的指令，sun JDK基于栈的体系结构来执行字节码    
线程在创建后，都会产生程序计数器和栈；  
程序计数器存放下一条要执行的指令在方法内的偏移量    
栈中存放了栈帧，每个方法每次调用都会产生栈帧，栈帧主要分为局部变量区和操作数栈，局部变量区存放方法中的局部变量和参数，操作数栈用于存放方法执行过程中产生的中间结果

### 编译执行    
解释执行的效率较低，为提升代码的执行性能，Sun JDK提供将字节码编译为机器码的支持，编译在运行时进行，通常称为 JIT编译器。


Sun JDK之所以没有选择在启动时就编译成机器码，原因有
- 解释执行更节省内存
- 启动时解释执行的启动速度更快
- 。。。

### 反射执行
基于反射可以动态调用一个对象实例中对应方法，访问查看对象的属性

反射和直接创建对象实例，调用方法的最大不同在于创建的过程

## 3.2 JVM内存管理
为了不乱用内存，保证JVM内存够用，需要掌握内存 分配和回收的知识

### 3.2.1 内存空间 
### 方法区
存放要加载的类的信息，类中的静态变量，final类型的常量，类中的Field信息，类中的方法信息       

Class对象的getName，isInterface等方法就是从这里获取数据

方法区是全局共享的，一定条件下它会被 GC，使用内存超出时会报错

在 Sun JDK中这块区域对应 Permanet Generation，又称为==持久代==，可通过 -XX:PermSize 及 -XX:MaxPermSize 来指定最大值和最小值

### 堆
用于存储 对象实例及数组值，==可以认为Java中所有通过new 创建的对象的内存都在此分配==

-Xms为JVM启动时申请的最小 Heap内存，默认为物理内存的 1/64但小于1GB   

-Xmx 为JVM可申请的最大Heap内存  

默认当空余堆内存小于 40%时，JVM会增大Heap 到 -Xmx 指定的大小，可通过 -XX:MinHeapFreeRatio= 来指定这个比例

当空余堆内存大于 70%时，JVM会减小到 -Xms 指定的大小，可通过 -XX:MaxHeapFreeRatio= 来指定最大空闲堆内存比例

为了避免运行时频繁调整 Heap的大小，通常将 -Xms 和 -Xmx的值设成一样

> 为了让内存回收更加高效，Sun JDK从1.2 开始对堆采用了 分代管理

#### 1.新生代  New Generation
大多数情况下，Java程序新建的对象从新生代分配内存，新生代由 

#### 2.老年代 Old Generation 

### 本地方法栈
用于支持native方法的执行，存储了每个native方法调用的状态，==在 Sun JDK的实现中，本地方法栈和JVM方法栈是同一个==

### PC寄存器和 JVM方法栈
每个线程均会创建 PC寄存器和 JVM方法栈，PC寄存器占用的可能是 CPU寄存器或操作系统内存， 

==JVM方法栈占用的为操作系统内存==，JVM方法栈空间不足时是抛出 StackoverflowError，可以通过 -Xss来指定栈的大小

JVM方法栈为线程私有，当方法运行完毕后，对应栈帧所占用的内存会自动释放

### 3.2.2 内存分配 
Java对象所占用的内存主要从堆上进行分配，堆是所有线程共享的
[源码分析：Java对象的内存分配](http://www.importnew.com/21075.html)
### 3.2.1 内存回收
### 收集器

### Sun JDK中的GC 方案
将JVM堆划分为新生代和老年代，基于对象存活时间的特性进行不同的 GC实现

### 3.2.4 JVM内存状况查看方法和分析工具

#### 1. 输出GC日志
JVM支持将日志输出到控制台或指定的文件中 
- 输出到控制台  
在JVM的启动参数中加入 
    - -XX:PrintGC 
    - -XX:+PrintGCDetails
    - -XX:+PrintGCTimeStamps
    - -XX:+PrintGCApplicationStoppedTime

- 输出到指定的文件

#### 2. GC Potal

#### 3.JConsole

#### 4. JVisualVM

#### 5.JMap

#### 6. JHat

## 3.3 JVM线程资源同步及交互机制
本节介绍JVM线程资源同步机制和线程之间的交互机制

### 3.3.1 线程资源同步机制

### 3.3.2 线程交互机制

### 3.3.3 线程状态及分析




