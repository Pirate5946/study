如果说HTTP 是因特网的信使，那么HTTP 报文就是它用来搬东西的包裹了。第1 章说明了HTTP 程序是怎样互相发送报文来完成工作的。本章则会介绍所有与HTTP 报文有关的事情——如何创建报文，以及如何理解它们。通过阅读本章，就可以了解编写自己的HTTP 应用程序所需掌握的大部分内容。具体来说，你会理解下列概念：
  ● . 报文是如何流动的；
  ● . HTTP 报文的三个组成部分（起始行、首部和实体的主体部分）；
  ● . 请求和响应报文之间的区别；
  ● . 请求报文支持的各种功能（方法）；
  ● . 和响应报文一起返回的各种状态码；
  ● . 各种各样的 HTTP 首部都是用来做什么的。
3.1　报文流			p46
HTTP 报文是在HTTP 应用程序之间发送的数据块。这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”及“下游”都是用来描述报文方向的。
3.1.1　报文流入源端服务器
HTTP 使用术语流入（inbound）和流出（outbound）来描述事务处理（transaction）的方向。报文流入源端服务器，工作完成之后，会流回用户的Agent 代理中（参见图3-1）。
3.1.2　报文向下游流动					p47
HTTP 报文会像河水一样流动。不管是请求报文还是响应报文，所有报文都会向下游（downstream） 流动（ 参见图3-2）。所有报文的发送者都在接收者的上游（upstream）。在图3-2 中，对请求报文来说，代理1 位于代理3 的上游，但对响应报文来说，它就位于代理3 的下游1。

3.2　报文的组成部分
HTTP 报文是简单的格式化数据块。看一下图3-3 给出的例子。每条报文都包含一条来自客户端的请求，或者一条来自服务器的响应。它们由三个部分组成：对报文进行描述的起始行（start line）、包含属性的首部（header）块，以及可选的、包含数据的主体（body）部分。
起始行和首部就是由行分隔的ASCII 文本。每行都以一个由两个字符组成的行终止序列作为结束，其中包括一个回车符（ASCII 码13）和一个换行符（ASCII 码10）。这个行终止序列可以写做CRLF。

3.2.1　报文的语法
这是请求报文的格式：
<method> <request-URL> <version>
<headers>
<entity-body>
例子：    GET /specials/saw-blade.gif HTTP/1.0
Host: www.joes-hardware.com
这是响应报文的格式（注意，只有起始行的语法有所不同）：
<version> <status> <reason-phrase>
<headers>
<entity-body>
下面是对各部分的简要描述。
• 方法（method）
客户端希望服务器对资源执行的动作。是一个单独的词，比如GET、HEAD 或POST。本章稍后将详细介绍方法。
• 请求URL（request-URL）
命名了所请求资源，或者URL 路径组件的完整URL。如果直接与服务器进行对话，只要URL 的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是URL 的主机/ 端口。第2 章详细地介绍了URL 的语法。
• 版本（version）
报文所使用的HTTP 版本，其格式看起来是这样的：HTTP/<major>.<minor>其中主要版本号（major）和次要版本号（minor）都是整数。本章稍后会详细说明HTTP 的版本问题。
• 状态码（status-code）
这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）。本章稍后提供了HTTP 规范定义的状态码及其含义的完整列表。
• 原因短语（reason-phrase）
数字状态码的可读版本，包含行终止序列之前的所有文本。本章稍后提供了HTTP 规范定义的所有状态码的原因短语示例。原因短语只对人类有意义，因此，比如说，尽管响应行HTTP/1.0 200 NOT OK 和 HTTP/1.0 200 OK 中原因短语的含义不同，但同样都会被当作成功指示处理。
• 首部（header）
可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些HTTP 版本，比如HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部。本章稍后会探讨各种HTTP 首部。
• 实体的主体部分（entity-body）
实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个CRLF 结束。第15 章详述了实体。

注意，一组HTTP 首部总是应该以一个空行（仅有CRLF）结束，甚至即使没有首部和实体的主体部分也应如此。但由于历史原因，很多客户端和服务器都在没有实体的主体部分时，（错误地）省略了最后的CRLF。为了与这些流行但不符合规则的实现进行互通，客户端和服务器都应该接受那些没有最后那个CRLF 的报文。

3.2.2　起始行
所有的HTTP 报文都以一个起始行作为开始。请求报文的起始行说明了要做些什么。响应报文的起始行说明发生了什么。
1. 请求行
请求报文请求服务器对资源进行一些操作。请求报文的起始行，或称为请求行，包含了一个方法和一个请求URL，这个方法描述了服务器应该执行的操作，请求URL描述了要对哪个资源执行这个方法。请求行中还包含HTTP 的版本，用来告知服务器，客户端使用的是哪种HTTP。所有这些字段都由空格符分隔。在图3-5a 中， 请求方法为GET， 请求URL 为/test/hi-there.txt， 版本为HTTP/1.1。在HTTP/1.0 之前， 并不要求请求行中包含HTTP 版本号。
2. 响应行
响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应报文的起始行，或称为响应行，包含了响应报文使用的HTTP 版本、数字状态码，以及描述操作状态的文本形式的原因短语。
所有这些字段都由空格符进行分隔。在图3-5b 中，HTTP 版本为HTTP/1.0，状态码为200（表示成功），原因短语为OK，表示文档已经被成功返回了。在HTTP/1.0之前，并不要求在响应中包含响应行。
3. 方法
请求的起始行以方法作为开始，方法用来告知服务器要做些什么。比如，在行“GET /specials/saw-blade.gif HTTP/1.0”中，方法就是GET。
HTTP 规范中定义了一组常用的请求方法。比如，GET 方法负责从服务器获取一个文档，POST 方法会向服务器发送需要处理的数据，OPTIONS 方法用于确定Web服务器的一般功能，或者Web 服务器处理特定资源的能力。
常用的HTTP方法。注意，有些方法的请求报文中有主体，有些则是无主体的请求。
方　　法			描　　述								是否包含主体
GET 			从服务器获取一份文档							否
HEAD 		只从服务器获取文档的首部					否
POST 		向服务器发送需要处理的数据						是
PUT 			将请求的主体部分存储在服务器上					是
TRACE 	对可能经过代理服务器传送到服务器上去的报文进行追踪		否
OPTIONS 	决定可以在服务器上执行哪些方法					否
DELETE 		从服务器上删除一份文档							否

并不是所有服务器都实现了表3-1 列出的所有7 种方法。而且，由于HTTP 设计得易于扩展，所以除了这些方法之外，其他服务器可能还会实现一些自己的请求方法。这些附加的方法是对HTTP 规范的扩展，因此被称为扩展方法。

4. 状态码
方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情。
状态码位于响应的起始行中。比如，在行HTTP/1.0 200 OK 中，状态码就是200。
客户端向一个HTTP 服务器发送请求报文时，会发生很多事情。幸运的话，请求会成功完成。但你不会总是那么幸运的。服务器可能会告诉你无法找到所请求的资源，你没有访问资源的权限，或者资源被移到了其他地方。状态码是在每条响应报文的起始行中返回的。会返回一个数字状态和一个可读的状态。数字码便于程序进行差错处理，而原因短语则更便于人们理解。可以通过三位数字代码对不同状态码进行分类。          
			   							   					    	 
200 到299 之间的状态码表示成功。
300 到399 之间的代码表示资源已经被移走了。
400 到499 之间的代码表示客户端的请求出错了。
500 到599 之间的代码表示服务器出错了。

常见状态码
状　态　码			原因短语					含　　义
200 					OK 					成功。请求的所有数据都在响应主体中
401 				Unauthorized（未授权） 		需要输入用户名和密码
404 				Not Found（未找到） 		服务器无法找到所请求URL 对应的资源

5. 原因短语
原因短语是响应起始行中的最后一个组件。它为状态码提供了文本形式的解释。比如，在行HTTP/1.0 200 OK 中，OK 就是原因短语。原因短语和状态码是成对出现的。原因短语是状态码的可读版本，应用程序开发者将其传送给用户，用以说明在请求期间发生了什么情况。HTTP 规范并没有提供任何硬性规定，要求原因短语以何种形式出现。本章稍后列出了状态码和一些建议使用的原因短语。
6. 版本号
版本号会以HTTP/x.y 的形式出现在请求和响应报文的起始行中。为HTTP 应用程序提供了一种将自己所遵循的协议版本告知对方的方式。
使用版本号的目的是为使用HTTP 的应用程序提供一种线索，以便互相了解对方的能力和报文格式。在与使用HTTP 1.1 的应用程序进行通信的HTTP 1.2 应用程序应该知道，它不能使用任何新的1.2 特性，因为使用老版本协议的应用程序很可能无法实现这些特性。
版本号说明了应用程序支持的最高HTTP 版本。但HTTP/1.0 应用程序在解释包含HTTP/1.1 的响应时，会认为这个响应是个1.1 响应，而实际上这只是响应应用程序所使用的协议等级，在这些情况下，版本号会在应用程序之间造成误解2。
注意，版本号不会被当作小数来处理。版本中的每个数字（比如HTTP/1.0 中的1和0）都会被当作一个单独的数字来处理。因此，在比较HTTP 版本时，每个数字都必须单独进行比较，以便确定哪个版本更高。比如，HTTP/2.22 就比HTTP/2.3 的版本要高，因为22 比3 大。

3.2.3　首部							p53
前一小节的重点是请求和响应报文的第一行（方法、状态码、原因短语和版本号）。跟在起始行后面的就是零个、一个或多个HTTP 首部字段
HTTP 首部字段向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名/ 值对的列表。

3.2.4	实体的主体部分
HTTP报文 的第三部分 是可选的 实体部分。实体的主体是HTTP报文的负荷。就是HTTP要传输的内容
HTTP报文  可以承载很多类型的数字数据：图片、视频、HTML文档、软件应用程序、电子邮件等

3.2.5		0.9版本的报文			p55


3.3　方法			p56
一台服务器要与HTTP1.1兼容，只要为其 资源实现 GET方法和 HEAD方法就可以了
3.3.1　安全方法

3.3.2　GET
GET 是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现此方法

3.3.3　HEAD
HEAD 方法与GET 方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。
使用HEAD，可以：
  ● 在不获取资源的情. 况下了解资源的情况（比如，判断其类型）；
  ● 通过查看响应中的状态码，看看某个对象是否存在；
  ● 通过查看首部，测试资源是否被修改了。
服务器开发者必须确保返回的首部与GET 请求所返回的首部完全相同。遵循
HTTP/1.1 规范，就必须实现HEAD 方法

3.3.4　PUT
与GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。有些发布系统允许用户创建Web 页面，并用PUT 直接将其安装到Web 服务器上去
PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL 命名的新文档，或者，如果那个URL 已经存在的话，就用这个主体来替代它。
因为PUT 允许用户对内容进行修改，所以很多Web 服务器都要求在执行PUT 之前，用密码登录。在第12 章中可以读到更多有关密码认证的内容。

3.3.5　POST
POST 方法起初是用来向服务器输入数据的3。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）。图3-10 显示了一个用POST 方法发起HTTP 请求——向服务器发送表单数据——的客户端。

3.3.6　TRACE
客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。
TRACE 请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP 应用程序组成的请求/ 响应链上，原始报文是否，以及如何被毁坏或修改过（参见图3-11）。
TRACE 方法主要用于诊断；也就是说，用于验证请求是否如愿穿过了请求/ 响应链。它也是一种很好的工具，可以用来查看代理和其他应用程序对用户请求所产生效果。
尽管TRACE 可以很方便地用于诊断，但它确实也有缺点，它假定中间应用程序对各种不同类型请求（不同的方法——GET、HEAD、POST 等）的处理是相同的。很多HTTP 应用程序会根据方法的不同做出不同的事情——比如，代理可能会将POST 请求直接发送给服务器，而将GET 请求发送给另一个HTTP 应用程序（比如Web 缓存）。TRACE 并不提供区分这些方法的机制。通常，中间应用程序会自行决定对TRACE 请求的处理方式。
TRACE 请求中不能带有实体的主体部分。TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本。

3.3.7　OPTIONS
OPTIONS 方法请求Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）。
这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式

3.3.8　DELETE
顾名思义，DELETE 方法所做的事情就是请服务器删除请求URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为HTTP 规范允许服务器在不通知客户端的情况下撤销请求

3.3.9　扩展方法
HTTP 被设计成字段可扩展的，这样新的特性就不会使老的软件失效了。扩展方法指的就是没有在HTTP/1.1 规范中定义的方法。服务器会为它所管理的资源实现一些HTTP 服务，这些方法为开发者提供了一种扩展这些HTTP 服务能力的手段。表3-5 列出了一些常见的扩展方法实例。这些方法就是WebDAV HTTP 扩展（参见第19 章）包含的所有方法，这些方法有助于通过HTTP 将Web 内容发布到Web 服务器上去。
并不是所有的扩展方法都是在正式规范中定义的，认识到这一点很重要。如果你定义了一个扩展方法，很可能大部分HTTP 应用程序都无法理解。同样，你的HTTP应用程序也可能会遇到一些其他应用程序在用的，而它并不理解的扩展方法。在这些情况下，最好对扩展方法宽容一些。如果能够在不破坏端到端行为的情况下将带有未知方法的报文传递给下游服务器，代理应尝试传递这些报文。如果可能破
坏端到端行为则应以501 Not Implemented（无法实现）状态码进行响应。最好按惯例“对所发送的内容要求严一点，对所接收的内容宽容一些”来处理扩展方法（以及一般的HTTP 扩展）。

3.4　状态码			p63
HTTP 状态码被分成了五大类。本节对这五类HTTP 状态码中的每一类都进行了总结。
状态码为客户端提供了一种理解事务处理结果的便捷方式。尽管并没有实际的规范对原因短语的确切文本进行说明，本节还是列出了一些原因短语示例。我们所列的是HTTP/1.1 规范推荐使用的原因短语。
3.4.1　100～199——信息性状态码
HTTP/1.1 向协议中引入了信息性状态码。这些状态码相对较新，关于其复杂性和感知价值存在一些争论，而受到限制

3.4.2　200～299——成功状态码
客户端发起请求时，这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求。

3.4.3　300～399——重定向状态码
重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。如果资源已被移动，可发送一个重定向状态码和一个可选的Location 首部来告知客户端资源已被移走，以及现在可以在哪里找到它（参见图3-14）。这样，浏览器就可以在不打扰使用者的情况下，透明地转入新的位置了。
总之，在对那些包含了重定向状态码的非HEAD 请求进行响应时，最好要包含一个实体，并在实体中包含描述信息和指向（多个）重定向URL 的链接——参见图3-14 的第一个响应报文。

3.4.4　400～499——客户端错误状态码
有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求报文，或者最常见的是，请求一个不存在的URL。浏览网页时，我们都看到过臭名昭著的404 Not Found 错误码——这只是服务器在告诉我们，它对我们请求的资源一无所知。
很多客户端错误都是由浏览器来处理的，甚至不会打扰到你。只有少量错误，比如404，还是会穿过浏览器来到用户面前。

3.4.5　500～599——服务器错误状态码
有时客户端发送了一条有效请求，服务器自身却出错了。这可能是客户端碰上了服务器的缺陷，或者服务器上的子元素，比如某个网关资源，出了错。代理尝试着代表客户端与服务器进行交流时，经常会出现问题。代理会发布5XX 服务器错误状态码来描述所遇到的问题（参见第6 章）。表3-10 列出了已定义的服务器错误状态码。


3.5　首部		p70
首部和方法配合工作，共同决定了客户端和服务器能做什么事情。本节快速介绍了使用标准HTTP 首部及一些没有在HTTP/1.1 规范（RFC 2616）中明确定义的首部的目的。附录C 对所有这些首部进行了更详细的总结。
在请求和响应报文中都可以用首部来提供信息，有些首部是某种报文专用的，有些首部则更通用一些。可以将首部分为五个主要的类型。
• 通用首部
这些是客户端和服务器都可以使用的通用首部。可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能。比如，Date 首部就是一个通用首部，每一端都可以用它来说明构建报文的时间和日期：
Date: Tue, 3 Oct 1974 02:16:00 GMT
• 请求首部
从名字中就可以看出，请求首部是请求报文特有的。它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据。例如，下面的Accept 首部就用来告知服务器客户端会接受与其请求相符的任意媒体类型：
Accept: */*
• 响应首部
响应报文有自己的首部集，以便为客户端提供信息（比如，客户端在与哪种类型的服务器进行交互）。例如，下列Server 首部就用来告知客户端它在与一个版本1.0 的Tiki-Hut 服务器进行交互：
Server: Tiki-Hut/1.0
.• 实体首部
实体首部指的是用于应对实体主体部分的首部。比如，可以用实体首部来说明实体主体部分的数据类型。例如，可以通过下列Content-Type 首部告知应用程序，数据是以iso-latin-1 字符集表示的HTML 文档：
Content-Type: text/html; charset=iso-latin-1
• 扩展首部
扩展首部是非标准的首部，由应用程序开发者创建，但还未添加到已批准的HTTP 规范中去。即使不知道这些扩展首部的含义，HTTP 程序也要接受它们并对其进行转发。


