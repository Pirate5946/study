>HTTP 规范对HTTP 报文解释得很清楚，但对HTTP 连接介绍的并不多，HTTP 连接是HTTP 报文传输的关键通道。

通过本章，可以了解到：

  ● HTTP 是如何使用 TCP 连接的；
  
  ● TCP 连接的时延、瓶颈以及存在的障碍；
  
  ● HTTP 的优化，包括并行连接、keep-alive（持久连接）和管道化连接；
  
  ● 管理连接时应该以及不应该做的事情。

### 4.1　	TCP连接			p80
世界上几乎所有的HTTP 通信都是由TCP/IP 承载的，TCP/IP 是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。

客户端应用程序可以打开一条TCP/IP 连接，连接到可能运行在世界任何地方的服务器应用程序。一旦连接建立起来了，在客户端和服务器的计算机之间交换的报文就永远不会丢失、受损或失序。
#### 4.1.1　TCP的可靠数据管道
HTTP 连接实际上就是TCP 连接及其使用规则。

TCP 连接是因特网上的可靠连接。要想正确、快速地发送数据，就需要了解TCP 的一些基本知识

TCP 为HTTP 提供了一条可靠的比特传输管道。从TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来

Web 浏览器通过TCP 连接与Web 服务器进行交互

（1）浏览器解析出主机名

（2）浏览器查询这个主机名的IP地址（DNS）

（3）浏览器获得端口号（80）

（4）浏览器发起到202.43.78.3端口80的连接

（5）浏览器向服务器发送一条HTTP GET报文

（6）浏览器从服务器读取HTTP响应报文

（7）浏览器关闭连接

#### 4.1.2　TCP流是分段的、由IP分组传送
TCP 的数据是通过名为IP 分组（或IP 数据报）的小数据块来发送的。

这样的话，如图4-3a 所示，HTTP 就是“HTTP over TCP over IP”这个“协议栈”中的最顶层了。


其安全版本HTTPS 就是在HTTP 和TCP 之间插入了一个（称为TLS 或SSL的）密码加密层（图4-3b）。


HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP 连接按序传输。

TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在IP 分组中，通过因特网进行传输（参见图4-4）。所有这些工作都是由TCP/IP 软件来处理的，HTTP 程序员什么都看不到。

每个TCP 段都是由IP 分组承载，从一个IP 地址发送到另一个IP 地址的。

每个IP分组中都包括：

• 一个 IP 分组首部（通常为 20 字节）；

• 一个 TCP 段首部（通常为 20 字节）；

• 一个 TCP 数据块（0 个或多个字节）。

IP 首部包含了源和目的IP 地址、长度和其他一些标记。TCP 段的首部包含了TCP端口号、TCP 控制标记，以及用于数据排序和完整性检查的一些数字值。

#### 4.1.3　保持TCP连接持续不断地运行
在任意时刻计算机都可以有几条TCP 连接处于打开状态。

TCP 是通过端口号来保持所有这些连接持续不断地运行。


TCP 连接是通过4 个值来识别的：
< 源IP 地址、源端口号、目的IP 地址、目的端口号>

这4 个值一起唯一地定义了一条连接。两条不同的TCP 连接不能拥有4 个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）。

#### 4.1.4　用TCP套接字编程
操作系统提供了一些操纵其TCP 连接的工具。

为了更具体地说明问题，我们来看一个TCP 编程接口。

表4-2 显示了套接字API 提供的一些主要接口。

这个套接字API向HTTP 程序员隐藏了TCP 和IP 的所有细节。套接字API 最初是为Unix 操作系统开发的，但现在几乎所有的操作系统和语言中都有其变体存在。

表4-2　对TCP连接进行编程所需的常见套接字接口函数			p83

客户端根据URL 判定出IP地址和端口号，并建立一条到服务器的TCP 连接（参见图4-6，C3）。

建立连接可能要花费一些时间，时间长短取决于服务器距离的远近、服务器的负载情况，以及因特网的拥挤程度。


一旦建立了连接，客户端就会发送HTTP 请求，服务器则会读取请求。


一旦服务器获取了整条请求报文，就会对请求进行处理，执行所请求的动作，并将数据写回客户端。


客户端读取数据，并对响应数据进行处理（参见图4-6，C7）。

### 4.2　对TCP性能的考虑
HTTP 紧挨着TCP，位于其上层，所以HTTP 事务的性能在很大程度上取决于底层TCP 通道的性能。

本节重点介绍了一些很重要的、对这些TCP 连接的性能考虑。理解了TCP 的某些基本性能特点之后，就可以更好地理解HTTP 的连接优化特性，这样就能设计实现一些更高性能的HTTP 应用程序了。

#### 4.2.1　HTTP事务的时延
注意，与建立TCP 连接，以及传输请求和响应报文的时间相比，事务处理时间可能是很短的。除非客户端或服务器超载，或正在处理复杂的动态资源，否则HTTP 时延就是由TCP 网络时延构成的。

HTTP 事务的时延有以下几种主要原因。

(1) 客户端首先需要根据URI 确定Web 服务器的IP 地址和端口号。如果最近没有对URI 中的主机名进行访问，通过DNS 解析系统将URI 中的主机名转换成一个IP地址可能要花费数十秒的时间。（幸运的是，大多数HTTP 客户端都有一个小的DNS 缓存，用来保存近期所访问站点的IP 地址。

如果
已经在本地“缓存”（记录）了IP 地址，查询就可以立即完成。因为大多数Web 浏览器浏览的都是
少数常用站点，所以通常都可以很快地将主机名解析出来。）

(2) 接下来，客户端会向服务器发送一条TCP 连接请求，并等待服务器回送一个请求接受应答。每条新的TCP 连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP 事务的话，这个值会快速地叠加上去。

(3) 一旦连接建立起来了，客户端就会通过新建立的TCP 管道来发送HTTP 请求。数据到达时，Web 服务器会从TCP 连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间。

(4) 然后，Web 服务器会回送HTTP 响应，这也需要花费时间。这些TCP 网络时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP 协议的技术复杂性也会对时延产生巨大的影响。

#### 4.2.2　性能聚焦区域
本节其余部分列出了一些会对HTTP 程序员产生影响的、最常见的TCP 相关时延，其中包括：

• TCP 连接建立握手；

• TCP 慢启动拥塞控制；

• 数据聚集的 Nagle 算法；

• 用于捎带确认的 TCP 延迟确认算法；

• TIME_WAIT 时延和端口耗尽。

如果要编写高性能的HTTP 软件，就应该理解上面的每一个因素。如果不需要进行这个级别的性能优化，可以跳过这部分内容。

#### 4.2.3　TCP连接的握手时延
建立一条新的TCP 连接时，甚至是在发送任意数据之前，TCP 软件之间会交换一系列的IP 分组，对连接的有关参数进行沟通（参见图4-8）。如果连接只用来传送少量数据，这些交换过程就会严重降低HTTP 的性能。

TCP 连接握手需要经过以下几个步骤。

(1) 请求新的TCP 连接时，客户端要向服务器发送一个小的TCP 分组（通常是40 ～60 个字节）。这个分组中设置了一个特殊的SYN 标记，说明这是一个连接请求。（参见图4-8a）。

(2) 如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个TCP 分组，这个分组中的SYN 和ACK 标记都被置位，说明连接请求已被接受（参见图4-8b）。

(3) 最后，客户端向服务器回送一条确认信息，通知它连接已成功建立（参见图4-8c）。现代的TCP 栈都允许客户端在这个确认分组中发送数据。

HTTP 程序员永远不会看到这些分组——这些分组都由TCP/IP 软件管理，对其是不可见的。HTTP 程序员看到的只是创建TCP 连接时存在的时延。

#### 4.2.4　延迟确认
由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以TCP 实现了自己的确认机制来确保数据的成功传输。

每个TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。

#### 4.2.5　TCP慢启动
TCP 数据传输的性能还取决于TCP 连接的使用期（age）。TCP 连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为TCP 慢启动（slow start），用于防止因特网的突然过载和拥塞。

#### 4.2.6　Nagle算法与TCP_NODELAY
TCP 有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入TCP 栈中——即使一次只放一个字节也可以！但是，每个TCP 段中都至少装载了40 个字节的标记和首部，所以如果TCP 发送了大量包含少量数据的分组，网络的性能就会严重下降

#### 4.2.7　TIME_WAIT累积与端口耗尽
TIME_WAIT 端口耗尽是很严重的性能问题，会影响到性能基准，但在现实中相对较少出现。大多数遇到性能基准问题的人最终都会碰到这个问题，而且性能都会变得出乎意料地差，所以这个问题值得特别关注。

### 4.3　HTTP连接的处理			p90


### 4.4　并行连接				p93

### 4.5　持久连接

#### 4.5.1　持久以及并行连接



#### 4.5.8　HTTP/1.1持久连接
HTTP/1.1 逐渐停止了对keep-alive 连接的支持，用一种名为持久连接（persistent connection）的改进型设计取代了它。持久连接的目的与keep-alive 连接的目的相同，但工作机制更优一些。

### 4.6　管道化连接


### 4.7　关闭连接的奥秘






